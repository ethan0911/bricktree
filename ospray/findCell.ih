// ======================================================================== //
// Copyright 2009-2015 Intel Corporation                                    //
//                                                                          //
// Licensed under the Apache License, Version 2.0 (the "License");          //
// you may not use this file except in compliance with the License.         //
// You may obtain a copy of the License at                                  //
//                                                                          //
//     http://www.apache.org/licenses/LICENSE-2.0                           //
//                                                                          //
// Unless required by applicable law or agreed to in writing, software      //
// distributed under the License is distributed on an "AS IS" BASIS,        //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //
// See the License for the specific language governing permissions and      //
// limitations under the License.                                           //
// ======================================================================== //

#pragma once 

// ours
#include "CellRef.ih"
#include "FindStack.ih"
#include "Chombo.ih"

  /* packet-based variant of findCell kernel */
extern CellRef findCell(const Chombo *uniform self,
                        const varying vec3f &_worldSpacePos,
                        const float minWidth)
{
  const vec3f worldSpacePos = max(make_vec3f(0.f),
                                  min(self->bounds.upper,_worldSpacePos));
  const varying float *const uniform  samplePos = &worldSpacePos.x;

  uniform FindStack stack[16];
  uniform FindStack *uniform stackPtr = pushStack(&stack[0],0);

  while (stackPtr > stack) {
    --stackPtr;
    if (stackPtr->active) {
      const uniform uint32 nodeID = stackPtr->nodeID;
      const uniform KDTreeNode &node = self->node[nodeID];
      if (isLeaf(node)) {
        for (uniform int i=getOfs(node);any(true);i++) {
          const ChomboBrick *uniform brick = self->item[i];
          if (brick->cellWidth >= minWidth) {
            const vec3f relBrickPos
              = (worldSpacePos - brick->bounds.lower) * brick->bounds_scale;
            // brick coords: integer cell coordinates inside brick
#if 0
            // OPT: the same calculations as below, just in
            // floats. this works as long as all values we calculate
            // with are fraction-less values (so essentially ints) and
            // fit into 24 bits mantissa (which they easily should for
            // any brick
            const vec3f f_bc = floor(relBrickPos * brick->f_dims);
            CellRef ret;
            const uint32 idx = (int)(f_bc.x + brick->f_dims.x*(f_bc.y+brick->f_dims.y*(f_bc.z)));
            ret.pos = brick->bounds.lower + f_bc*brick->cellWidth;
            ret.value = brick->value[idx];
            ret.width = brick->cellWidth;
#else
            const vec3i bc = make_vec3i(relBrickPos * (brick->f_dims));
            // clamped brick coordinates
            // const vec3i cbc = max(make_vec3i(0),min(bc,brick->dims-make_vec3i(1)));
            CellRef ret;
            const uint32 idx = bc.x + brick->dims.x*(bc.y+brick->dims.y*(bc.z));
            ret.pos = make_vec3f(brick->box.lower+bc)*brick->cellWidth;
            ret.value = brick->value[idx];
            ret.width = brick->cellWidth;
#endif
            return ret;
          }
        }
      } else {
        const uniform uint32 childID = getOfs(node);
        if (samplePos[getDim(node)] >= getPos(node)) {
          stackPtr = pushStack(stackPtr,childID+1);
        } else {
          stackPtr = pushStack(stackPtr,childID);
        }
      }
    }
  }
}

extern CellRef findLeafCell(const Chombo *uniform self,
                            const varying vec3f &_worldSpacePos)
{
  const vec3f worldSpacePos = max(make_vec3f(0.f),
                                  min(self->bounds.upper,_worldSpacePos));
  const varying float *const uniform  samplePos = &worldSpacePos.x;

  uniform FindStack stack[16];
  uniform FindStack *uniform stackPtr = pushStack(&stack[0],0);

  while (stackPtr > stack) {
    --stackPtr;
    if (stackPtr->active) {
      const uniform uint32 nodeID = stackPtr->nodeID;
      const uniform KDTreeNode node = self->node[nodeID];
      if (isLeaf(node)) {
        const ChomboBrick *uniform brick = self->item[getOfs(node)];
        const vec3f relBrickPos
          = (worldSpacePos - brick->bounds.lower) * brick->bounds_scale;
        // brick coords: integer cell coordinates inside brick
        // OPT: the same calculations as below, just in
        // floats. this works as long as all values we calculate
        // with are fraction-less values (so essentially ints) and
        // fit into 24 bits mantissa (which they easily should for
        // any brick
        const vec3f f_bc = floor(relBrickPos * brick->f_dims);
        CellRef ret;
        const uint32 idx = (int)(f_bc.x + brick->f_dims.x*(f_bc.y+brick->f_dims.y*(f_bc.z)));
        ret.pos = brick->bounds.lower + f_bc*brick->cellWidth;
        ret.value = brick->value[idx];
        ret.width = brick->cellWidth;
        return ret;
      } else {
        const uniform uint32 childID = getOfs(node);
        if (samplePos[getDim(node)] >= getPos(node)) {
          stackPtr = pushStack(stackPtr,childID+1);
        } else {
          stackPtr = pushStack(stackPtr,childID);
        }
      }
    }
  }
}


