// ======================================================================== //
// Copyright 2009-2015 Intel Corporation                                    //
//                                                                          //
// Licensed under the Apache License, Version 2.0 (the "License");          //
// you may not use this file except in compliance with the License.         //
// You may obtain a copy of the License at                                  //
//                                                                          //
//     http://www.apache.org/licenses/LICENSE-2.0                           //
//                                                                          //
// Unless required by applicable law or agreed to in writing, software      //
// distributed under the License is distributed on an "AS IS" BASIS,        //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //
// See the License for the specific language governing permissions and      //
// limitations under the License.                                           //
// ======================================================================== //

#pragma once

struct KDTreeNode {
  uint32 dim_and_ofs;
  uint32 pos_or_numItems;
};

inline uint32 getDim(const KDTreeNode & node)
{
  return node.dim_and_ofs >> 30;
}

inline uint32 getOfs(const KDTreeNode & node)
{
  return node.dim_and_ofs & ((1<<30)-1);
}

inline bool isLeaf(const KDTreeNode & node)
{
  return getDim(node) == 3;
}

inline float getPos(const KDTreeNode & node)
{
  return floatbits(node.pos_or_numItems);
}

inline float getNumItems(const KDTreeNode & node)
{
  return node.pos_or_numItems;
}

inline uniform uint32 getDim(const uniform KDTreeNode & node)
{
  return node.dim_and_ofs >> 30;
}

inline uniform uint32 getOfs(const uniform KDTreeNode & node)
{
  return node.dim_and_ofs & ((1<<30)-1);
}

inline uniform bool isLeaf(const uniform KDTreeNode & node)
{
  return getDim(node) == 3;
}

inline uniform float getPos(const uniform KDTreeNode & node)
{
  return floatbits(node.pos_or_numItems);
}

inline uniform float getNumItems(const uniform KDTreeNode & node)
{
  return node.pos_or_numItems;
}


struct ChomboBrick {
  /*! bounding box of integer coordinates of cells. note that
    this EXCLUDES the width of the rightmost cell: ie, a 4^3
    box at root level pos (0,0,0) would have a _box_ of
    [(0,0,0)-(3,3,3)] (because 3,3,3 is the highest valid
    coordinate in this box!), while its bounds would be
    [(0,0,0)-(4,4,4)]. Make sure to NOT use box.size() for the
    grid dimensions, since this will always be one lower than
    the dims of the grid.... */
  box3i box;
  //! level this brick is at
  int   level;
  // width of each cell in this level
  float cellWidth;

  /* world bounds, including entire cells. ie, a 4^3 root brick
     at (0,0,0) would have bounds [(0,0,0)-(4,4,4)] (as opposed
     to the 'box' value, see above!) */
  box3f bounds;
  // pointer to the actual data values stored in this brick
  float *value;
  // dimensions of this box's data
  vec3i dims;
  // scale factor from grid space to world space (ie,1.f/cellWidth)
  float gridToWorldScale;
};

struct Chombo {
  Volume    super; //!< inherited from superclass

  ChomboBrick          *uniform brick;
  /*! "item list" array - each leaf node in the tree points into this
    array, and the 'num' elements follwing the pointed-to-location
    are the bricks stored at this leaf */
  ChomboBrick *uniform *uniform item;
  KDTreeNode           *uniform node;

  vec3i rootGridDims;
  // float finestCellWidth;
};
