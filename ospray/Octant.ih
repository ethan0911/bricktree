// ======================================================================== //
// Copyright 2009-2015 Intel Corporation                                    //
//                                                                          //
// Licensed under the Apache License, Version 2.0 (the "License");          //
// you may not use this file except in compliance with the License.         //
// You may obtain a copy of the License at                                  //
//                                                                          //
//     http://www.apache.org/licenses/LICENSE-2.0                           //
//                                                                          //
// Unless required by applicable law or agreed to in writing, software      //
// distributed under the License is distributed on an "AS IS" BASIS,        //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //
// See the License for the specific language governing permissions and      //
// limitations under the License.                                           //
// ======================================================================== //

// ours
#include "findCell.ih"
#include "findLeaf.ih"

/*! the 8 cellrefs that make up an octant. allows for finding multiple
  of the corners in a same 'initialLocation' */
struct Octant {
  CellRef cr[2][2][2];
};

inline void clear(Octant &oct)
{
  oct.cr[0][0][0].width = 0.f;
  oct.cr[0][0][1].width = 0.f;
  oct.cr[0][1][0].width = 0.f;
  oct.cr[0][1][1].width = 0.f;
  oct.cr[1][0][0].width = 0.f;
  oct.cr[1][0][1].width = 0.f;
  oct.cr[1][1][0].width = 0.f;
  oct.cr[1][1][1].width = 0.f;
}

/* packet-based variant of findCell kernel */
extern void initialFind(const Chombo *uniform self,
                        Octant &oct,
                        const varying vec3f &_worldSpacePos,
                        const float minWidth)
{
  // print("ENTER OCTANT\n");
  clear(oct);
  const vec3f pos = max(make_vec3f(0.f),
                        min(self->bounds.upper,_worldSpacePos));
  const varying float *const uniform  samplePos = &pos.x;
  
  const uint32 kdLeafNodeID = findLeaf(self,pos);
  foreach_unique (nodeID in kdLeafNodeID) {
    const uniform KDTreeNode &node = self->node[nodeID];
    for (uniform int i=getOfs(node);any(true);i++) {
      const ChomboBrick *uniform brick = self->item[i];
      if (brick->cellWidth >= minWidth) {
        // print("enter leaf\n");
        const float *uniform v = brick->value;
        const vec3f relBrickPos
          = (pos - brick->bounds.lower) * brick->bounds_scale;
        // brick coords: integer cell coordinates inside brick
        // OPT: the same calculations as below, just in
        // floats. this works as long as all values we calculate
        // with are fraction-less values (so essentially ints) and
        // fit into 24 bits mantissa (which they easily should for
        // any brick
        const float cw = brick->cellWidth;
        const vec3f f_bc = floor(relBrickPos * brick->f_dims);
        const float f_idx = f_bc.x + brick->f_dims.x*(f_bc.y+brick->f_dims.y*(f_bc.z));
        const uint32 idx = (int)f_idx;
        const vec3f P0 = brick->bounds.lower + f_bc*cw;
        set(oct.cr[0][0][0],P0,cw,v[idx]);
        
        const vec3f lcc = centerOf(oct.cr[0][0][0]);
        // octant signs:
        const float sx = pos.x < lcc.x ? -1.f : +1.f;
        const float sy = pos.y < lcc.y ? -1.f : +1.f;
        const float sz = pos.z < lcc.z ? -1.f : +1.f;
        
        // index offsets to neighbor cells
        const float f_idx_dx = sx;
        const float f_idx_dy = sy*brick->f_dims.x;
        const float f_idx_dz = sz*brick->f_dims.x*brick->f_dims.y;
        
        // coordinates of neighbor
        const vec3f P1 = P0+make_vec3f(sx,sy,sz)*cw;
        
        const bool dx_valid = P1.x >= brick->bounds.lower.x & P1.x < brick->bounds.upper.x;
        const bool dy_valid = P1.y >= brick->bounds.lower.y & P1.y < brick->bounds.upper.y;
        const bool dz_valid = P1.z >= brick->bounds.lower.z & P1.z < brick->bounds.upper.z;
        
        if (dx_valid) {
          set(oct.cr[0][0][1],
              make_vec3f(P1.x,P0.y,P0.z),cw,v[(int)(f_idx+f_idx_dx)]);
        }
        if (dy_valid) {
          set(oct.cr[0][1][0],
              make_vec3f(P0.x,P1.y,P0.z),cw,v[(int)(f_idx+f_idx_dy)]);
          if (dx_valid) {
            set(oct.cr[0][1][1],
                make_vec3f(P1.x,P1.y,P0.z),cw,v[(int)(f_idx+f_idx_dx+f_idx_dy)]);
          }
        }
        if (dz_valid) {
          set(oct.cr[1][0][0],
              make_vec3f(P0.x,P0.y,P1.z),cw,v[(int)(f_idx+f_idx_dz)]);
          if (dx_valid) {
            set(oct.cr[1][0][1],
                make_vec3f(P1.x,P0.y,P1.z),cw,v[(int)(f_idx+f_idx_dx+f_idx_dz)]);
          }
          if (dy_valid) {
            set(oct.cr[1][1][0],
                make_vec3f(P0.x,P1.y,P1.z),cw,v[(int)(f_idx+f_idx_dy+f_idx_dz)]);
            if (dx_valid) {
              set(oct.cr[1][1][1],
                  make_vec3f(P1.x,P1.y,P1.z),cw,v[(int)(f_idx+f_idx_dx+f_idx_dy+f_idx_dz)]);
            }
          }
        }
        break;
      }
    }
  }
}
  



