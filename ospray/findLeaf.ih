// ======================================================================== //
// Copyright 2009-2015 Intel Corporation                                    //
//                                                                          //
// Licensed under the Apache License, Version 2.0 (the "License");          //
// you may not use this file except in compliance with the License.         //
// You may obtain a copy of the License at                                  //
//                                                                          //
//     http://www.apache.org/licenses/LICENSE-2.0                           //
//                                                                          //
// Unless required by applicable law or agreed to in writing, software      //
// distributed under the License is distributed on an "AS IS" BASIS,        //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //
// See the License for the specific language governing permissions and      //
// limitations under the License.                                           //
// ======================================================================== //

#pragma once 

// ours
#include "CellRef.ih"
#include "FindStack.ih"
#include "Chombo.ih"

// return the kdtree's NODE ID that containst he leaf foro given position
extern int findLeaf(const Chombo *uniform self,
                    const varying vec3f &_worldSpacePos)
{
  const vec3f worldSpacePos = max(make_vec3f(0.f),
                                  min(self->bounds.upper,_worldSpacePos));
  const varying float *const uniform  samplePos = &worldSpacePos.x;
  
  uniform FindStack stack[16];
  uniform FindStack *uniform stackPtr = pushStack(&stack[0],0,true);
  
  while (1) {
    --stackPtr;
    if (stackPtr->active) {
      // const uniform uint32 nodeID = stackPtr->nodeID;
      uniform uint32 nodeID = stackPtr->nodeID;
      while (1) {
        const uniform KDTreeNode &node = self->node[nodeID];
        if (isLeaf(node)) 
          return nodeID;
        else {
          const uniform uint32 childID = getOfs(node);
          const bool goRight = samplePos[getDim(node)] >= getPos(node);
          const bool goLeft = !goRight;
          if (any(goLeft)) {
            if (goRight) {
              stackPtr = pushStack(stackPtr,childID+1,goRight);
              break;
            } 
            nodeID = childID;
          } else {
            nodeID = childID+1;
          }
        }
      }
    }
  }
}

