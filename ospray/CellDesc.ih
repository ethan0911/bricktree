// ======================================================================== //
// Copyright 2009-2015 Intel Corporation                                    //
//                                                                          //
// Licensed under the Apache License, Version 2.0 (the "License");          //
// you may not use this file except in compliance with the License.         //
// You may obtain a copy of the License at                                  //
//                                                                          //
//     http://www.apache.org/licenses/LICENSE-2.0                           //
//                                                                          //
// Unless required by applicable law or agreed to in writing, software      //
// distributed under the License is distributed on an "AS IS" BASIS,        //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //
// See the License for the specific language governing permissions and      //
// limitations under the License.                                           //
// ======================================================================== //

#pragma once

#include "BrickTree.ih"

/*! \file CellDesc.ih all infrastructure for describing, enumerating,
  and locating logical cells in grid space. note this is for ease of
  experimentation only, so we will NOT try to use uniform values,
  cache addresses, etc; this is all using floats in logical grid
  space, fully re-traversing whatever needs to get traversed to find
  nodes even if prior information from prev queries might help to
  reduce this cost */

/*! a cell descriptor. each cell is described by the grid space
    position of its lower-left-front vertex, and the width/level of
    this cell. */
struct CellDesc
{
  /* lower-left-front coordinate of the cell */
  vec3f pos;
  /* though nominally the width of the cell, this also serves as a
     level descriptor: the root cell has width 1, all additional level
     shrinks by .25 */
  float width;
};

/*! constructor */
inline CellDesc makeCD(const vec3f pos, float width=0.f)
{
  CellDesc cd;
  cd.pos = pos;
  cd.width = width;
  return cd;
}

/*! create celldesc for a neighor of given cell */
inline CellDesc neighborCD(const CellDesc cd, const vec3i delta)
{
  return makeCD(cd.pos + make_vec3f(delta) * cd.width,cd.width);
}

/*! get the root cell descriptor of given cd */
inline CellDesc rootCD(const CellDesc cd)
{
  return makeCD(floor(cd.pos), 1.f);
}

inline vec3f centerOf(const CellDesc &cd)
{
  return cd.pos + 0.5f * cd.width;
}

/*! translate world position into appropriate grid space
    position. Input is a world space position (something inside the
    object's world-space bounding box; output is transformed into
    logical grid space */
inline CellDesc toGridSpace(const BrickTreeVolume *uniform self, const vec3f worldSpacePos)
{
  const vec3f unitPos = (worldSpacePos - self->super.boundingBox.lower)
    * rcp(self->super.boundingBox.upper - self->super.boundingBox.lower);
  return makeCD(unitPos
                * make_vec3f(self->rootGridDims) 
                * self->validFractionOfRootGrid,
                0.f);
}


