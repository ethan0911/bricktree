// ======================================================================== //
// Copyright 2009-2015 Intel Corporation                                    //
//                                                                          //
// Licensed under the Apache License, Version 2.0 (the "License");          //
// you may not use this file except in compliance with the License.         //
// You may obtain a copy of the License at                                  //
//                                                                          //
//     http://www.apache.org/licenses/LICENSE-2.0                           //
//                                                                          //
// Unless required by applicable law or agreed to in writing, software      //
// distributed under the License is distributed on an "AS IS" BASIS,        //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //
// See the License for the specific language governing permissions and      //
// limitations under the License.                                           //
// ======================================================================== //

#pragma once

#include "GridPos.ih"

/*! descriptor for a cell. rather than elaborate cell and level
    indices we instead use the global base position (the lower left
    front corner) and width, which are equivalent) */
struct CellRef {
  GridPos gp;
  /*! base coordinates of that block, in that tree (in [0,1]^3) */
  vec3f blockPos;
  /*! fractional component in that block */
  float value;
  float blockWidth;
  int blockID;
};

inline CellRef findLeafCell(const MSAMRVolume *uniform self, 
                             const varying vec3f worldSpacePos)
{
  CellRef cell;
  cell.gp = makeGridPos(self,makeCD(worldSpacePos,0.f));
  uniform bool dbg = false;
  foreach_unique (rootCellID in cell.gp.rootCellID) {
    uniform SumDataBlock *uniform dataBlockArray
      = self->dataBlock+self->firstDataBlockOfTree[rootCellID];
    uniform SumIndexBlock *uniform indexBlockArray
      = self->indexBlock+self->firstIndexBlockOfTree[rootCellID];
    uniform int32 *uniform indexBlockOfArray 
      = (uniform int32*)self->blockInfo + self->firstDataBlockOfTree[rootCellID];
    
    int blockID = 0;
    cell.blockPos = make_vec3f(0.f);
    cell.blockWidth = 1.f;
    
    while (1) {
      const float cellWidth = cell.blockWidth * 0.25f;
      const vec3i cID = make_vec3i(4.f * cell.gp.frac);
      cell.gp.frac = 4.f*cell.gp.frac - make_vec3f(cID);

      // determine ID of child, if available
      int childBlockID = -1;
      const int indexBlockID = indexBlockOfArray[blockID];
      if (indexBlockID >= 0) {
        childBlockID = indexBlockArray[indexBlockID].child[cID.z][cID.y][cID.x];
      }
      if (childBlockID >= 0) {
        // cell we hit is a leaf cell...
        cell.blockPos   = cell.blockPos + make_vec3f(cID)*cellWidth;
        cell.blockWidth = cellWidth;
        blockID         = childBlockID;
      } else {
        cell.blockID = blockID;
        cell.value = dataBlockArray[blockID].value[cID.z][cID.y][cID.x];
        break;
      }
    }
  }
  return cell;
}

