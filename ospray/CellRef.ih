// ======================================================================== //
// Copyright 2009-2015 Intel Corporation                                    //
//                                                                          //
// Licensed under the Apache License, Version 2.0 (the "License");          //
// you may not use this file except in compliance with the License.         //
// You may obtain a copy of the License at                                  //
//                                                                          //
//     http://www.apache.org/licenses/LICENSE-2.0                           //
//                                                                          //
// Unless required by applicable law or agreed to in writing, software      //
// distributed under the License is distributed on an "AS IS" BASIS,        //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //
// See the License for the specific language governing permissions and      //
// limitations under the License.                                           //
// ======================================================================== //

// ours
#include "ChomboVolume.ih"

/*! a reference to a given cell on a given level; this is what a 'node location' kernel will return */
struct CellRef {
  //! lower left front position, in unit grid space
  vec3f pos;
  //! width of cell, also doubles as level indicator 
  float cellWidth; 
  //! ID of the kd-tree's leaf node that we hit
  int nodeID;
  //! value at this cell
  float value;
};

inline vec3f centerOf(const CellRef &cr)
{ return cr.pos + make_vec3f(0.5f*cr.cellWidth); }

inline CellRef findCell(Chombo *uniform self,
                        const varying vec3f &worldSpacePos,
                        const float minWidth)
{
  const vec3f gridPos = worldSpacePos;
  float samplePos[3];
  samplePos[0] = gridPos.x;
  samplePos[1] = gridPos.y;
  samplePos[2] = gridPos.z;

  uniform uint32 nodeStack[16];
  varying bool activeStack[16];
  nodeStack[0] = 0;
  unmasked { activeStack[0] = false; }
  activeStack[0] = true;
  uniform uint32 stackPtr = 1;

  CellRef ret;
  while (stackPtr > 0) {
    --stackPtr;
    if (!activeStack[stackPtr]) 
      continue;

    const uniform nodeID = nodeStack[stackPtr];
    const uniform KDTreeNode &node = self->node[nodeID];
    if (isLeaf(node)) {
      foreach_unique(mw in minWidth) {
        
        // find the leaf that has the given brick width...
        const ChomboBrick *uniform brick = NULL;
        for (uniform int i=getOfs(node);;i++) {
          if (i>=getOfs(node)+getNumItems(node))
            print("LEAF NOT FOUND!");
          brick = self->item[i];
          if (brick->cellWidth >= minWidth) 
            break;
        }
        
        // const ChomboBrick *uniform brick = self->item[getOfs(node)+getNumItems(node)-1];
        const vec3f relBrickPos
          = (worldSpacePos - brick->bounds.lower)
          * rcp(brick->bounds.upper - brick->bounds.lower);
        // brick coords: integer cell coordinates inside brick
        const vec3i bc = make_vec3i(relBrickPos * make_vec3f(brick->dims));
        // clamped brick coordinates
        const vec3i cbc = max(make_vec3i(0),min(bc,brick->dims-make_vec3i(1)));
        ret.nodeID = nodeID;
        int idx = cbc.x + brick->dims.x*(cbc.y+brick->dims.y*(cbc.z));
        ret.pos = make_vec3f(brick->box.lower+bc)*brick->cellWidth;
        ret.value = brick->value[idx];
        ret.cellWidth = brick->cellWidth;
      }
      return ret;
    } else {
      const uniform uint32 childID = getOfs(node);
      if (samplePos[getDim(node)] >= getPos(node)) {
        unmasked { activeStack[stackPtr] = 0; }
        nodeStack[stackPtr] = childID+1;
        activeStack[stackPtr] = 1;
        stackPtr++;
      } else {
        unmasked { activeStack[stackPtr] = 0; }
        nodeStack[stackPtr] = childID;
        activeStack[stackPtr] = 1;
        stackPtr++;
      }
    }
  }
}


inline CellRef findLeafCell(Chombo *uniform self,
                            const varying vec3f &worldSpacePos)
{
  return findCell(self,worldSpacePos,0.f); 
}
