// ======================================================================== //
// Copyright 2009-2015 Intel Corporation                                    //
//                                                                          //
// Licensed under the Apache License, Version 2.0 (the "License");          //
// you may not use this file except in compliance with the License.         //
// You may obtain a copy of the License at                                  //
//                                                                          //
//     http://www.apache.org/licenses/LICENSE-2.0                           //
//                                                                          //
// Unless required by applicable law or agreed to in writing, software      //
// distributed under the License is distributed on an "AS IS" BASIS,        //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //
// See the License for the specific language governing permissions and      //
// limitations under the License.                                           //
// ======================================================================== //

#pragma once

#include "CellDesc.ih"
#include "GridPos.ih"
#include "CellRef.ih"

/*! used to return info about the closest cell descriptor we could
    find when locating a specified CD. */
struct CellQuery {
  CellDesc cd;
  float    value;
  bool     isLeaf;
};

/*! given the _desired_ CD, find the leaf cell that this would be
    achild of, and return both the leaf value, as well as the _actual_
    cd that this leaf was found. note that though 'width=0' is usually
    not an allowed cell descriptor it is perfectly valid to use a
    'desredCD' with width=0 - this merely means that we'll traverse
    until we reach a leaf 
*/
inline CellQuery cellQuery(const MSAMRVolume *uniform self,
                           const varying CellDesc desiredCD)
{
  CellQuery cq;
  CellRef cell;
  cell.gp = makeGridPos(self,desiredCD);
  foreach_unique (rootCellID in cell.gp.rootCellID) {
    uniform SumDataBlock *uniform dataBlockArray
      = self->dataBlock+self->firstDataBlockOfTree[rootCellID];
    uniform SumIndexBlock *uniform indexBlockArray
      = self->indexBlock+self->firstIndexBlockOfTree[rootCellID];
    uniform int32 *uniform indexBlockOfArray 
      = (uniform int32*)self->blockInfo + self->firstDataBlockOfTree[rootCellID];
    
    int blockID = 0;
    cell.blockPos = make_vec3f(0.f);
    cell.blockWidth = 1.f;
    
    while (1) {
      const float cellWidth = cell.blockWidth * 0.25f;
      const vec3i cID = make_vec3i(4.f * cell.gp.frac);
      cell.gp.frac = 4.f*cell.gp.frac - make_vec3f(cID);

      if (cellWidth <= desiredCD.width) {
        cq.cd.pos = cell.blockPos;
        cq.cd.width = cellWidth;
        cq.value = dataBlockArray[blockID].value[cID.z][cID.y][cID.x];
        cq.isLeaf = false;
        break;
      }

      // determine ID of child, if available
      int childBlockID = -1;
      const int indexBlockID = indexBlockOfArray[blockID];
      if (indexBlockID >= 0) {
        childBlockID = indexBlockArray[indexBlockID].child[cID.z][cID.y][cID.x];
      }
      if (childBlockID >= 0) {
        // cell we hit is a leaf cell...
        cell.blockPos   = cell.blockPos + make_vec3f(cID)*cellWidth;
        cell.blockWidth = cellWidth;
        blockID         = childBlockID;
      } else {
        cell.blockID = blockID;
        cq.cd.pos
          = cell.blockPos
          + make_vec3f(cell.gp.rootCell) 
          + make_vec3f(cID)*cellWidth;
        cq.cd.width = cellWidth;
        cq.value = dataBlockArray[blockID].value[cID.z][cID.y][cID.x];
        cq.isLeaf = true;
        break;
      }
    }
  }
  return cq;
}

