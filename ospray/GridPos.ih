#include "MultiSum.ih"

/*! \file GridPos.ih Helper infrastructure for transforing a unit
    'sample' pos to a grid space position, computing fration, root
    cell ID, etc */


struct GridPos {
  /*! root cell coords, in int */
  vec3i rootCell;

  /*! linear root cell ID (index in root node array) */
  int32 rootCellID;

  /*! actual position in grid space, in floats */
  vec3f  pos;

  /*! fractional part of 'pos' */
  vec3f  frac;
};

/*! translate world position into appropriate grid space
    position. Input is a world space position (something inside the
    object's world-space bounding box; output is transformed into
    logical grid space */
inline GridPos makeGridPos(const MultiSumAMRVolume *uniform self, const vec3f worldSpacePos)
{
  // print("wc\n %\n %\n-> %\n",worldSpacePos.x,worldSpacePos.y,worldSpacePos.z);
  GridPos gp;
  const vec3f unitPos
    = (worldSpacePos - self->super.boundingBox.lower)
    * rcp(self->super.boundingBox.upper - self->super.boundingBox.lower);

  gp.pos = unitPos
    * make_vec3f(self->rootGridDims) 
    * self->validFractionOfRootGrid;
  gp.rootCell = clamp(make_vec3i(gp.pos),
                      make_vec3i(0),
                      make_vec3i(self->rootGridDims)-make_vec3i(1));
  gp.rootCellID
    = (gp.rootCell.x + 
       self->rootGridDims.x*(gp.rootCell.y +
                             self->rootGridDims.y*(gp.rootCell.z)));
  gp.frac = gp.pos - make_vec3f(gp.rootCell);
  return gp;
}

