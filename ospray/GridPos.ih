// ======================================================================== //
// Copyright 2009-2015 Intel Corporation                                    //
//                                                                          //
// Licensed under the Apache License, Version 2.0 (the "License");          //
// you may not use this file except in compliance with the License.         //
// You may obtain a copy of the License at                                  //
//                                                                          //
//     http://www.apache.org/licenses/LICENSE-2.0                           //
//                                                                          //
// Unless required by applicable law or agreed to in writing, software      //
// distributed under the License is distributed on an "AS IS" BASIS,        //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //
// See the License for the specific language governing permissions and      //
// limitations under the License.                                           //
// ======================================================================== //

#pragma once

#include "BrickTree.ih"

/*! \file GridPos.ih Helper infrastructure for transforing a unit
    'sample' pos to a grid space position, computing fration, root
    cell ID, etc */
struct GridPos {

  vec3f pos;

  /*! root cell coords, in int */
  vec3i rootCell;

  /*! linear root cell ID (index in root node array) */
  int32 rootCellID;

  /*! fractional part of 'pos' */
  vec3f  frac;
};

// /*! translate world position into appropriate grid space
//     position. Input is a world space position (something inside the
//     object's world-space bounding box; output is transformed into
//     logical grid space */
// inline GridPos makeGridPos(const MSAMRVolume *uniform self, const vec3f worldSpacePos)
// {
//   // print("wc\n %\n %\n-> %\n",worldSpacePos.x,worldSpacePos.y,worldSpacePos.z);
//   GridPos gp;
//   gp.pos = toGridSpace(self,worldSpacePos);
//   gp.rootCell = clamp(make_vec3i(gp.pos),
//                       make_vec3i(0),
//                       make_vec3i(self->rootGridDims)-make_vec3i(1));
//   gp.rootCellID
//     = (gp.rootCell.x + 
//        self->rootGridDims.x*(gp.rootCell.y +
//                              self->rootGridDims.y*(gp.rootCell.z)));
//   gp.frac = gp.pos - make_vec3f(gp.rootCell);
//   return gp;
// }

/*! translate world position into appropriate grid space
    position. Input is a world space position (something inside the
    object's world-space bounding box; output is transformed into
    logical grid space */
inline GridPos makeGridPos(const BrickTreeVolume *uniform self, const CellDesc cd)
{
  // print("wc\n %\n %\n-> %\n",worldSpacePos.x,worldSpacePos.y,worldSpacePos.z);
  GridPos gp;
  gp.pos = cd.pos;
  gp.rootCell = clamp(make_vec3i(gp.pos),
                      make_vec3i(0),
                      make_vec3i(self->rootGridDims)-make_vec3i(1));
  gp.rootCellID
    = (gp.rootCell.x + 
       self->rootGridDims.x*(gp.rootCell.y +
                             self->rootGridDims.y*(gp.rootCell.z)));
  gp.frac = gp.pos - make_vec3f(gp.rootCell);
  return gp;
}

