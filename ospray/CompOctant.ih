// ======================================================================== //
// Copyright 2009-2015 Intel Corporation                                    //
//                                                                          //
// Licensed under the Apache License, Version 2.0 (the "License");          //
// you may not use this file except in compliance with the License.         //
// You may obtain a copy of the License at                                  //
//                                                                          //
//     http://www.apache.org/licenses/LICENSE-2.0                           //
//                                                                          //
// Unless required by applicable law or agreed to in writing, software      //
// distributed under the License is distributed on an "AS IS" BASIS,        //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //
// See the License for the specific language governing permissions and      //
// limitations under the License.                                           //
// ======================================================================== //

// ours
#include "findCell.ih"
#include "findLeaf.ih"

/* actually this is more of a virtual 'dual cell' than an octant. it
   contains all the 8 compintaions of {P0,P1}x{x,y,z}, as follows:
   sample position [iz][iy][ix] is (P_ix.x,P_iy.y,P_iz,z),
   width[iz][iy][ix] is the cell with on the level on which this
   sample was found (at most level for sample [0,0,0]!), and value the
   value of that sample. */
struct CompactOctant {
  vec3f P0, P1;
  float width[2][2][2];
  float value[2][2][2];
};
typedef CompactOctant CompOct;

inline void clear(CompactOctant &oct)
{
  oct.width[0][0][0] = 0.f;
  oct.width[0][0][1] = 0.f;
  oct.width[0][1][0] = 0.f;
  oct.width[0][1][1] = 0.f;
  oct.width[1][0][0] = 0.f;
  oct.width[1][0][1] = 0.f;
  oct.width[1][1][0] = 0.f;
  oct.width[1][1][1] = 0.f;
}

inline void out(const CompactOctant &oct)
{
  print("CompOct\n");
  print(" P0 "); out(oct.P0); print("\n");
  print(" P1 "); out(oct.P1); print("\n");
  for (uniform int iz=0;iz<2;iz++)
    for (uniform int iy=0;iy<2;iy++)
      for (uniform int ix=0;ix<2;ix++) {
        print("corner[%][%][%]\n",iz,iy,iz);
        print("  width %\n",oct.width[iz][iy][ix]);
        print("  value %\n",oct.value[iz][iy][ix]);
      }
}

inline void check(CompactOctant &oct)
{
  if (oct.width[0][0][0] == 0.f||
      oct.width[0][0][1] == 0.f||
      oct.width[0][1][0] == 0.f||
      oct.width[0][1][1] == 0.f||
      oct.width[1][0][0] == 0.f||
      oct.width[1][0][1] == 0.f||
      oct.width[1][1][0] == 0.f||
      oct.width[1][1][1] == 0.f) {
    print("invalid compoct! (some width==0.f)\n");
    out(oct);
  }
}

inline vec3f centerOf(const CompactOctant &oct)
{
  return oct.P0 + 0.5f*oct.width[0][0][0];
}



/*! initial find operation for a small octant: this will traverse down
  to the leaf of 'samplePos', and fill in at least oct[0,0,0]. If
  any other cells on the given leaf brick fit any other corners of
  this octant, they will get filled in, too */
extern void initialFind(const Chombo *uniform self,
                        CompactOctant &oct,
                        const varying vec3f &pos,
                        const float minWidth);

/*! fill in addiitonal corners, where applicable. 'nextPos' must be a cellRef */
extern void findOthers(const Chombo *uniform self,
                       CompactOctant &o,
                       const vec3f &pos,
                       const float minWidth);

/*! find the eight cells made up by the combination of {P0,P1}x{x,y,z}.
  this will return both value AND width of the found cell.
  
the order of P0 and P1 does NOT matter; ie, it is perfectly valid that
any coooridnate of P1 is less than P0's */
extern void findEightCellsNotOrdered(const Chombo *uniform self,
                                     CompactOctant &o,
                                     const float minWidth);

/*! find the eight corner values given by all combinations of
  {P0,P1}{xyz}. do NOT set the width values, and always traverse
  down to the leaf level 

  P0 MUST be less than P1
*/
extern void findEightCornerValuesOrdered(const Chombo *uniform self,
                                         CompactOctant &o);




                       
