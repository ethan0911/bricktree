// ======================================================================== //
// Copyright 2009-2015 Intel Corporation                                    //
//                                                                          //
// Licensed under the Apache License, Version 2.0 (the "License");          //
// you may not use this file except in compliance with the License.         //
// You may obtain a copy of the License at                                  //
//                                                                          //
//     http://www.apache.org/licenses/LICENSE-2.0                           //
//                                                                          //
// Unless required by applicable law or agreed to in writing, software      //
// distributed under the License is distributed on an "AS IS" BASIS,        //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //
// See the License for the specific language governing permissions and      //
// limitations under the License.                                           //
// ======================================================================== //

// ours
#include "CellRef.ih"
#include "FindStack.ih"
#include "Chombo.ih"

/* actually this is more of a virtual 'dual cell' than an octant. it
   contains all the 8 compintaions of {P0,P1}x{x,y,z}, as follows:
   sample position [iz][iy][ix] is (P_ix.x,P_iy.y,P_iz,z),
   width[iz][iy][ix] is the cell with on the level on which this
   sample was found (at most level for sample [0,0,0]!), and value the
   value of that sample. */
struct OctCorners {
  struct Corner {
    float value, width;
    bool isLeaf;
  };
  vec3f P0, P1;
  Corner c[8];
};

/*! enum to symbolically iterate the 8 corners of an octant */
enum { C000=0, C001,C010,C011,C100,C101,C110,C111 };

//! set an octant corner to given value, width, and leaf flag
inline void set(OctCorners::Corner &c,
                const float v, const float w, const bool l)
{ 
  c.value = v;
  c.width = w;
  c.isLeaf = l;
}

//! set an octant corner to given cellref. leafflag does NOT get set
inline void set(OctCorners::Corner &c,
                const CellRef &cr)
{ 
  c.value = cr.value;
  c.width = cr.width;
}

/*! perform trilinear inteprolation with given weight and 8 input
    values */
inline float lerp(float value[8], const vec3f &w)
{
  const float f000 = value[C000];
  const float f001 = value[C001];
  const float f010 = value[C010];
  const float f011 = value[C011]; 
  const float f100 = value[C100];
  const float f101 = value[C101];
  const float f110 = value[C110];
  const float f111 = value[C111];
    
  const float f00 = (1.f-w.x)*f000 + w.x*f001;
  const float f01 = (1.f-w.x)*f010 + w.x*f011;
  const float f10 = (1.f-w.x)*f100 + w.x*f101;
  const float f11 = (1.f-w.x)*f110 + w.x*f111;
    
  const float f0 = (1.f-w.y)*f00+w.y*f01;
  const float f1 = (1.f-w.y)*f10+w.y*f11;
    
  const float f = (1.f-w.z)*f0+w.z*f1;
  return f;
}

inline float lerp(const OctCorners &oct, const vec3f &w)
{
    
  const float f000 = oct.c[C000].value;
  const float f001 = oct.c[C001].value;
  const float f010 = oct.c[C010].value;
  const float f011 = oct.c[C011].value; 
  const float f100 = oct.c[C100].value;
  const float f101 = oct.c[C101].value;
  const float f110 = oct.c[C110].value;
  const float f111 = oct.c[C111].value;
    
  const float f00 = (1.f-w.x)*f000 + w.x*f001;
  const float f01 = (1.f-w.x)*f010 + w.x*f011;
  const float f10 = (1.f-w.x)*f100 + w.x*f101;
  const float f11 = (1.f-w.x)*f110 + w.x*f111;
    
  const float f0 = (1.f-w.y)*f00+w.y*f01;
  const float f1 = (1.f-w.y)*f10+w.y*f11;
    
  const float f = (1.f-w.z)*f0+w.z*f1;
  return f;
}

/*! default-initialize an octant to invalid values */
inline void clear(OctCorners &oct)
{
  oct.c[C000].width = 0.f;
  oct.c[C001].width = 0.f;
  oct.c[C010].width = 0.f;
  oct.c[C011].width = 0.f;
  oct.c[C100].width = 0.f;
  oct.c[C101].width = 0.f;
  oct.c[C110].width = 0.f;
  oct.c[C111].width = 0.f;
}

/*! find the eight cells made up by the combination of {P0,P1}x{x,y,z}.
  this will return both value AND width of the found cell.
  
the order of P0 and P1 does NOT matter; ie, it is perfectly valid that
any coooridnate of P1 is less than P0's */
extern void findEightCellsNotOrdered(const Chombo *uniform self,
                                     OctCorners &o,
                                     const float minWidth);



                       
